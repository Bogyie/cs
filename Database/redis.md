## 레디스(Redis)
레디스는 데이터베이스중 하나로 저 단어를 풀어서 쓰면 Remote Dictionary Server 이다. 즉, 원격 우리가 자주사용하는 딕셔너리 자료구조를 쓰는 서버이다.

### 레디스의 특징
1. 오픈소스 소프트웨어이다. 
2. 인메모리 데이터 저장소이다.
> 레디스는 모든 데이터를 메모리에 저장하고 조회한다.
3. 캐시서버를 제공한다.
4. 다양한 자료구조를 제공한다.
> 어떻게 보면 다른 인메모리 솔루션과의 가장 큰 차이점이다. 
5. NoSQL 데이터베이스이다. 

레디스를 한마디로 정의 하면 __'레디스는 고성능 키-값 저장소로서 문자열, 리스트, 해시, 셋, 정렬된 셋 형식의 데이터를 지원하는 NoSQL이다'__

### 레디스는 인메모리 데이터베이스이다.
- 디스크에 데이터를 저장하는 다른 데이터베이스들(mySQL, oracle 등)과는 다르게 레디스는 메모리에 데이터를 저장해서 더 빠르게 데이터를 가져올 수 있다. 
- 하지만, 레디스는 다른 인메모리 데이터베이스들과는 다르게 다르게 디스크에도 데이터를 저장 할 수 있어서 영속성 또한 보장해준다. (메모리는 컴퓨터가 꺼지면 데이터가 다 날라간다.)

### 레디스의 영속성
> 영속성: 프로그램이 종료되더라도 데이터가 유지됨

__레디스 스냅샷__
데이터 영구 저장을 위해 메모리에 저장된 모든 데이터를 디스크로 저장한다. 스냅샷이라 불리는 이유는 특정 시점의 메모리를 사진을 찍듯이 그대로 디스크에 저장하기 때문이다.

- 장점: 메모리의 스냅샷을 그대로 뜬것이기 때문에, 서버를 restart시에 snapshot만 불러와도 되서 편하다.

- 단점: snapshot을 추출하는데 오랜 시간일 걸리며, 레디스가 중간에 장애가 생겨 멈추면 마지막으로 백업한 snapshot이후의 데이터를 잃는다.

__AOF(Append Only File)__
AOF는 데이터 영구 저장을 위해 레디스가 지원하는 두번재 기능이다. 레디스가 수신하는 모든 쓰기 명령어를 aof파일에 기록해 데이터를 보관한다. 

- 장점: 데이터 유실이 발생하지 않는다.

- 단점: aof파일은 스냅샷에 비해 더 많은 디스크 용량 차지. 또 모든 명령어를 일일이 파일에 기록하므로 스냅샷에 비해 더 느린 응답시간을 제공.(restart시에 느림)

__권장 사항__  
스냅샷과 AOF방식을 혼합해 사용하는 것을 추천한다.
주기적으로 snapshot으로 백업하고, 다음 snapshot까지의 저장을 AOF방식으로 수행한다. 그러면 서버가 restart될 때 백업된 snapshot을 reload하고, 소량의 AOF로그만 사용하면 되기 때문에, restart 시간을 절약하고 데이터의 유실을 방지할 수 있다.


### 캐시
나중에 올 정보를 미리 저장했다가 빠르게 서비스 해주는것 
레디스는 캐시용도로도 사용된다.

__캐시 구조__  
데이터베이스에서 캐시를 사용하기도 하는데 대표적으로 사용되는 두가지 방식을 한번 보자.

__Look Aside Cache__
![images](/images/lookAside.png)  
Client에서 요청이들어오면
1. 먼저 데이터가 있는지 캐시를 확인한다. 
2. 캐시에 데이터가 있으면 캐시에서 데이터를 가져온다. 
3. 캐시에 데이터가 없으면 DB에서 데이터를 가져온다.
4. DB에서 가져온 데이터를 캐시에 저장한다.  
> 가장 일반적으로 많이 사용되는 방식이다. 
  
__Write Back__
![images](/images/writeBack.png)
1. Client에서 들어온 데이터를 먼저 캐시에 저장.
2. 캐시에 있는 데이터를 특정 시간 동안 모은다.
3. 캐시에 있는 데이터를 DB에 한번에 저장.
4. DB에 데이터가 저장되면 캐시에서 삭제.

> 모든 요청마다 DB에 저장하는것보다 이렇게 캐시에서 모아서 일괄적으로 저장해주는 방식(매 요청마다 DB에 저장하는것 보다 빠름)

> 단점은 장애가 생겨서 rebooting되면 캐시에 저장되어 있던 데이터 들이 다 날라간다.

> 로그를 데이터베이스에 저장할때 자주 사용되는 방식이다.


### 레디스의 자료구조 
레디스가 지원하는 데이터형은 총 5개다. 레디스는 거대한 키-값 저장소이다. 
![images](/images/keyValue.png)
키 하나에 데이터형 하나가 저장되는 단순한 구조를 가진다. 이 단순함이 익히기 쉽고 직관적이라는 장점을 주지만 또 저장된 데이터를 가공하는데 제한이 있다는 단점이 있다. 그래서 레디스는 다양한 종류의 데이터형과 명령들을 통해 보완하고 있다. 

![images](/images/redisData.png)
1. 문자열
단순한 키-값 매핑 구조이다.
인증토큰을 저장하는데 자주 사용된다.

2. 해시 데이터
해시는 문자열 필드와 값으로 이루어진 맵 구조로 되어있다.

3. 셋 데이터
셋은 중복을 허용하지 않는 집합형태의 자료구조이며, 정렬되어 있지 않다. 
특정 user의 친구 list를 찾거나 follow목록을 찾는데 주로 사용된다(중복을 허용하지 않기 때문에).

4. 정렬된 셋 데이터
셋 데이터와 유사한 구조를 가지고 있지만, 부과적으로 오름차순으로 정렬되어 있다.
유저랭킹보드 같은 곳 정렬을 필요로 하는 곳에 자주 쓰인다. 

5. 리스트 데이터
저장 순서를 기억하는 데이터 구조로 중복을 허용한다.

> 레디스에서는 문자열과 정렬된 셋이 가장 자주 쓰인다.

> __레디스와 멤캐시드의 차이__  
캐시서버인 멤캐시드와 많이 비교된다. 레디스가 멤캐시드와 동일한 기능을 제공할 수 있다. 하지만 멤캐시드는 NoSQL이 아니다. 멤캐시드는 영속적이지 않다. 또, 레디스는 맴캐시드와 다르게 다양한 자료구조를 제공한다. 


### 레디스 운영시 주의 사항

__메모리 관리__  
메모리에 데이터를 저장하기 때문에 메모리 관리가 매우 중요하다.
메모리를 넘어가는 용량을 처리시에 swap을 사용한다. 하지만 swap을 사용시에 디스크에 정보를 넣었다 뺐다 해야되기 때문에 latency(지연)이 발생한다. 

또, 메모리를 사용하는 만큼 [메모리 파편화](https://github.com/NKLCWDT/cs/blob/main/Operating%20System/%EB%A9%94%EB%AA%A8%EB%A6%AC.md) 문제 또한 피해갈 수 없다. 다양한 사이즈를 가지는 데이터보다는 유사한 크기의 데이터를 저장하는 경우가 메모리 파편화를 조금이라도 피해갈 수 있다.

__O(N)의 명령어 사용 자제__  
레디스의 또 다른 특징 중 하나가 싱글 쓰레드이다. 싱글 쓰레드는 한번에 한 명령어 밖에 처리하지 못한다. 따라서 시간이 오래 걸리는 명령어를 처리하는 동안 다른 명령어들을 수행하지 못해 전체적으로 느려질 수가 있다. 따라서, O(N)의 시간 복잡도를 가지는 명령어들 Keys(모든 키를 순회하는 명령어), FlushALL(데이터 날리는 명령어), Get All Collections(Collection안에 있는 데이터를 모두 가져옴)을 사용시에 속도가 느려질 수 있다.
단, 데이터가 100개 정도로 적으면 상관없음 하지만 10만개 정도로 많을시에는 속도가 느려지는 문제 발생

### CAP정리
![images](/images/cap.png)  
Consistency(일관성), Availability(가용성), Partition Tolerance(분할 허용성)라는 뜻을 가지고 분산 컴퓨터 시스템을 설명하는데 사용되는 이론이다.

분산시스템을 이해하기 위한 예로는 우리가 어플리케이션 개발시에 웹서버와 DB서버를 동일한 시스템에 설치하지 않는다. 보통 웹서버와 DB서버는 각각 다른 하드웨어에 설치 한다. 이렇게 단일 시스템이 아닌 '다중 시스템 환경에서 소프트웨어가 작동하는 것'을 분산 컴퓨팅이라고 한다. 대부분의 NoSQL은 분산 환경에서 잘 동작하도록 설계되어있고 일관성, 가용성, 분할 허용성 중에 두가지의 속성 만을 지원하고 나머지 한 속성은 특정한 조건에서만 만족한다. 

![images](/images/분산시스템.png)  
사진에서 보이듯이 분산 시스템을 구성하는 각각의 하드웨어 또는 소프트웨어를 '노드'라고 부르며, 동일한 기능을 수행하는 노드들의 모임을 클러스터라고 한다. 
분산 시스템은 하나 혹은 그 이상의 다중 클러스터로 구성될 수 있다. 다중클러스터에서 각 클러스터 간의 연결은 네트워크를 기반으로 한다.

1. Consistency(일관성)  
- 동시성 혹은 동일성이라고도 한다. "다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터인것을 보증하는것" 이다. 
- 모든 읽기에 대해서 DB노드가 항상 동일한 데이터를 가지고 있어야 한다는 것이다.
- NoSQL에서는 빠른 분산처리를 위해서 희생하기도 한다. 

2. Availability(가용성)  
- 모든 클라이언트의 읽기와 쓰기 요청에 대해 항상 응답이 가능한 것을 보증한다.(내고장성이라고도 한다)
- 예를 들면, 클러스터 내의 몇개의 DB노드가 고장이 났더라도 정상적인 서비스가 가능해야 한다(읽기, 쓰기등). 


 
3. Partition Tolerance (네트워크 분할 허용성) 
![images](/images/분산시스템.png) 
- 네트워크 (메시지 전달)이 단절되더라도 시스템은 정상적으로 동작해야한다.  
- 예를 들면, 위에 분산시스템에 있는 노드들이 서울과 대전에 있는 노드를 사용하여 구성이되어 있다고 가정해보자.(왼쪽에 있는 클러스터가 서울, 오른쪽에 있는 클러스터가 대전을 담당하는 클러스터라고 정해보자)
- 서울과 대전간의 네트워크 장애가 발생해 서로 통신이 불가능 할때도 각 노드에 접속한 클라이언트의 읽기와 쓰기가 동작하면 '시스템은 분할 허용성을 지원하다'고 표현할 수 있다.

레디스는 여기서 CP이다.


### 참고자료
- https://brunch.co.kr/@jehovah/20
- https://azderica.github.io/00-db-cap/
- https://book.naver.com/bookdb/book_detail.nhn?bid=7334741
- https://www.youtube.com/watch?v=Gimv7hroM8A&t=1s
- https://www.youtube.com/watch?v=mPB2CZiAkKM&t=4024s
- https://bcho.tistory.com/654

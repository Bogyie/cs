# 교착상태(Deadlock)
Process나 thread가 결코 일어날 수 없는 특정 event를 기다리는 상태  
좀 더 자세히 말하자면, 둘 이상의 프로세스(아님 쓰레드)가 서로 점유하고 있는 자원을 서로 기다릴때 무한대기 상태에 빠지는것을 말한다.  
조금 더 일상적인 예시를 들어보자
![Images](/images/deadlock.png)  
<br>
이 사진에서 보면 A라는 사람은 노트북이 있지만 충전기가 없어서 대기중이고 B라는 사람은 노트북 충전기가 있지만 노트북이 없어서 대기중이다. 하지만 둘다 서로의 일이 급해서 양보할 생각이 없다. 이런 상황에서는 아무도 자기가 하고자 하는 것을 할 수 없다. 이런 상태가 바로 교착상태이다.  

또 다른 예를 들면, 우리는 취업을 하기 위해 다양한 경험을 해야하지만, 우리는 그 경험을 쌓기 위해 취업을 해야한다.

__실제 시스템에서의 교착상태예시__
![images](/images/deadlock2.png)  
<br>
우선 사진을 보면 멤버라는 테이블이 있고 멤버 A와 B가 각자 포인트를 가지고 있다. 동시에 두 트랜잭션이 들어왔다고 가정한다.
트랜잭션1은 멤버 A의 포인트를 빼서 B한테 주는 로직이고 트랜잭션2는 B의 포인트를 빼서 A한테 주게 된다. 상대방의 포인트를 주기위해 본인의 포인트 차감을 위해 트랜잭션1은 A의 포인트에 트랜잭션2는 B의 포인트에 접근해 lock을 걸고 점유한다. 이후 상대방에게 포인트를 추가해주기 위해 접근했을 때는 이미 lock이 걸려있는 상태이기때문에 대기하게 되면서 교착상태(Deadlock)에 빠지게 되는것이다.  

![images](/images/deadlock3.png)  
<br>
__교착상태 발생의 4가지 조건__  
- 상호배제
  - 여러 프로세스가 동시에 한 자원에 접근하지 못하도록한다. 
  - 한번에 한 프로세스밖에 자원을 가질 수 있다.  

- 점유와 대기
  - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스

- 비선점 조건
  - 프로세스에서 자원을 할당 받은 후 프로세스가 완료되기 전까지 system에서 process의 제어를 빼앗을 수 없다.

- 순환대기 조검
  - 대기 프로세스들이 순환형태로 자원을 대기하고 있어야 한다. 

## __교착상태 해결 방법__  
__교착상태 무시__
- Deadlock이 드물게 발생하는 곳에서 자주 쓰인다.
- 교착상태가 드물게 발생하는데 해결하기 위해 비용을 지불한다면 더 효율성이 떨어지기 때문이다.
- 만약 교착 상태 발생시에 사용자가 프로세스를 죽이거나 시스템 자체를 재부팅해야 한다.
- window와 unix에서 이러한 방법을 사용한다.
  
__교착상태 예방__  
위에 있는 데드락의 발생조건중 하나라도 발생하지 않게 예방하는 방법이다.
  - 상호배제 조건 방지: 한번에 여러 프로세스가 공유자원을 사용할 수 있게 한다. 프린터같은 경우에는 적용하지 못한다.

  - 점유와 대기조건 방지: 프로세스가 작업 수행전에 필요한 자원을 모두 요청하고 획득해야한다. 이렇게 되면 자원의 효율성이 떨어진다. 예를 들면, 시험전에 책 3권으로 공부할 예정인데 책 3권중 1권이 아직 배송중이라 그 책 한권이 도착할때 까지 공부하지 않고 기다린다. 

  - 비선점 조건 방지: 이미 할당된 자원에 선점권이 없어야한다. 하지만 비선점 조건 사용시 어떤 프로세스든 중간에 해당 자원을 사용할 수 있어서 기존에 사용중이던 작업 내용을 잃을 수도 있다.

  - 순환형 방지: 모든 자원에 순서를 부여해서 오름차순으로만 자원을 요청할 수 있게 한다. 하지만, 이 조건을 사용하면 필요 자원은 훨씬 오래전부너 할당 받은 상태가 되야 하므로 자원 낭비가 일어난다.

__교착상태 회피__  
위를 보면 deadlock예방법이 얼마나 비효율적인지 알 수 있다. 이런면을 보충하기 위해 나온것이 교착상태 회피이다.

여기서 중요한 두가지 개념이 있다.   

Safe State : 이 키워드는 시스템의 프로세스들이 요청하는 모든 자원을, Deadlock을 발생시키지 않으면 모두에게 할당해줄 수 있다면 안전상태 즉 safe state에 있다고 한다.

Safe Sequence: 이렇게 특정한 순서로 프로세스에 자원할당, 실행,종료들의 작업을 할때 deadlock이 발생하지 않는 순서를 안전순서 즉, safe sequence라고 한다.

회피알고리즘은 자원할당 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 하는것이다. 대표적인 알고리즘으로는 은행원알고리즘이있다.

__은행원 알고리즘__
다익스트라가 제안한 기법중하나로 미리 설정된 모든 자원들의 할당량을 가지고 시뮬레이션해서 safe state에 들 수 있는지 검사한다. 즉, 대기중인 프로세스들의 활동에 대해서 교착상태 가능성을 미리 조사한다. 이름은 은행에서 사용되는 대출이 개개인에게 가능한지 확인하는 은행시스템에서 가져왔기 때문에 은행원 알고리즘이라고 불리게 되었다.

예시를 보자,
![images](/images/bankingSystem.png)
<br>
은행은 100달러를 가지고 돈을 빌리려는 고객은 3명이다. 고객은 필요한 돈이 다 있어야 문제해결 후 상환을 할 수 있다. 은행은 우선 각각의 고객에게 20, 30, 30달러를 빌려줬다. 그럼 이제 첫번째 사람은 40, 두번째 사람은 10, 그리고 마지막 사람은 20 달러가 더 필요하다.

그럼 은행에 남은 돈은 20인데 어떻게 해야 이 세명에게 돈을 다 빌려줄 수 있을까?  
우선 고객2나 고객3에게 돈을 먼저 빌려줘야 그 사람들이 돈을 갚아 나머지 고객들에게 돈을 빌려 줄 수 있다. 그러면 이런 순서들로 돈을 빌려 줄 수 있게 된다.
- 고객2 - 고객1 - 고객3   
- 고객2 - 고객3 - 고객1   
- 고객3 - 고객1 - 고객2  
- 고객3 - 고객2 - 고객1  

이렇게 모든 사람들에게 돈을 빌려주고 받을 수 있는 상태를 위에 나온  안전상태(safe state)라고 할 수 있다.  
또 이런 순서들이 안전순서(safe sequence)라고 한다.  

또 은행원알고리즘이 잘 수행되려면 세가지가 필요하다.
- Max: 각 고객들이 얼마나 맥시멈으로 돈을 요구할지
- Allocated: 각 고객들이 현재 빌린 돈이 얼마인지
- Available: 은행이 보유한 돈이 얼마인지, 빌려줄 수 있는돈

그럼이제 프로세스로 예시를 들어보자.
![images](/images/bankAlgorithm.png)
<br>
처음에 시스템이 총 12개의 자원이 있다고 가정한다면  
여기서 프로세스에 할당된 자원의 합은 총 5+2+2=9이다. 이제 여기서 safe sequence를 찾아보자  
- 지금 할당가능한 자원은 12-9 =3개이다. 
- 필요한 자원의 수를 보면 p1만 할당이 가능하다. 3-2 =1개의 자원이 남는다.
- 실행이 끝난 p1은 자신에게 할당된 모든 자원을 반납하면서 1+4=5개의 자원이 사용가능하게 되었다.
- 이제 p0에게 자원이 할당가능하게 되었다 (5-5=0).
- p0이 할당받은 자원을 실행 후 반납한다. (0+10=10)
- 이 후 p2에게 자원이 할당 가능하다.

__은행원 알고리즘의 단점__
- 할당할 수 있는 자원의 수가 일정해야한다.
- 사용자 수가 일정해야한다.
- 최대자원 요구량을 미리 알아야한다.
- 프로세스들은 유한한 시간안에 자원 반납해야한다.

이러한 이유들로 교착상태가 자주 살생하는곳은 예방과 회피보다 탐지 및 회복을 더 많이 사용한다.

__Deadlock 회복 및 탐지__
Deadlock예방이나 회피를 사용하지 않을때, 데드락이 발생할 수 있으니 이때 deadlock을 탐지 및 회복을 하는 알고리즘이다.

__탐지 기법__
- 하나의 인스턴스를 가지는 시스템 :  
RAG(Resource Allocation Graph)자원할당 그래프를 통해서 알수 있다. 자원 할당 그래프로부터 자원 노드를 제거하고 적절하게 간선을 결합한 그래프인 wait for
>자원할당 그래프는시스템의 프로세스 및 자원의 상태를 나타내는 그래프이다. 얼마나 많은 자원이 사용가능한지 얼마나 할당이 되었는지 각 프로세스의 요청은 얼마인지를 나타내는 그래프.
- 여러개의 인스텀스를 가지는 시스템 :  
은행알고리즘과 비슷한 교착상태 탐지 알고리즘을 사용한다. 은행원 알고리즘에서 max와 need가 request로 달라져있다.
![images](/images/deadlockDetection.png)


__회복기법__
Deadlock을 탐지기법을 통해 발견시에 데드락으로부너 회복하기 위한 방법
- process를 1개 이상 중지시키기
  - 교착 상태에 빠진 모든 프로세스를 중지시킨다. 계속 연산중이던 프로세스들도 모두 일시에 중단되서 부분결과가 폐기될 수 있는 부작용이 있음
  - 프로세스 하나씩 중단 시킬때 마다 탐지 알고리즘으로 deadlock 탐지하면서 회복. 하지만, 이 방법도 매번 탐지 알고리즘을 호출 하고 수행해야하므로 부담이 되는 작업이다.  
  - 자원 선점하기  
  교착 상태에 관련된 프로세스로부터 자원을 선점하고, 선점된 자원을 다른 프로세스에 할당하여 교착 상태에서 시스템을 복구할 가능성이 있다. 

  ## 기아 상태(Starvation)
  특정 프로세스보다 우선순위가 낮아 원하는 자원을 계속 할당받지 못하는 상태이다. 주로 priority scheduling에서 일어난다.

  __Priority Scheduling__
  모든 프로세스에 우선순위를 주고 그 우선순위에 다라서 CPU가 할당되고 수행된다. 또 시간을 고려하지 않기 때문에 걸리는 시간이 짧아도 우선순위가 높은 process에 할당된다. 

  __Aging__
  기아 상태를 회피하기 위해 낮은 우선순위를 가진 프로세스들을 기다린 만큼 우선순위를 높여주는 방법이다.
  ![images](/images/aging.png)
  <br>

이렇게 우선순위를 매겨서 실행하는 기법들을 사용할때는 aging기법이 필수이다.

## Livelock
2개이상의 thread나 process들이 계속 서로에게 왔다갔다하면서 서로 맞지 않아 신호가 맞을 때까지 진행하지 못해서 마치 행동은 일어나지만 block된 것처럼 보이는 현상을 말한다.  

예를 들면, 두 사람이 마주쳤을때 비켜주기 위해 같은 방향으로 움직이는 것을 계속 반복하는것.


> 참고자료
- https://chanhuiseok.github.io/posts/cs-2/
- https://www.geeksforgeeks.org/deadlock-detection-recovery/?ref=lbp
- https://jhnyang.tistory.com/102
- https://www.youtube.com/watch?v=FXzBRD3CPlQ
- ttps://velog.io/@underlier12/OS-24-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%99%80-%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C

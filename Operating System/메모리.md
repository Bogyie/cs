# Memory(메모리)
- 데이터들의 모음 
- 명령어와 처리된 데이터들의 모음이다. 
- 큰 배열과 단어와 byte들의 그룹으로 구성되어 있다.

## Main memory
- 현대 컴퓨터의 작업에서 중심이다. 
- 즉, CPU나 I/O 시스템에서 빠르게 정보에 access할 수 있도록 컴퓨터가 실시간으로 이용하는 데이터 저장하는 공간이다.
- 프로그램과 정보들이 프로세서에 의해 활용되는 동안 있는 곳이다. 
- RAM(Random Access Memory)이라고도 불린다.

## Memory Allocation(메모리 할당)
메모리는 메모리에 상주하는 운영체제를 위한 것과 사용자 프로세스를 위한것으로 나뉜다. 메인메모리는 운영체제뿐만 아니라 여러 사용자의 프로세스도 수용해야됨. 그래서 메모리의 각 영역은 목적에 맞게 효율적으로 관리되어야한다.  

## Contigous memory allocation(연속적 메모리 할당)
우리가 컴퓨터를 사용하면 동시에 여러 프로그램을 사용하는데 이것을 multi programming 환경이라고 할 수 있다. 이런 환경에서는 여러 프로세스가 동시에 메모리에 올라와 있는 것이 바람직 하기에 메모리에 올라오고자 입력 큐에서 기다리고 있는 프로세스 들에게 메모리를 얼마큼씩 할당하는 것이 좋은가 생각해야한다. 하나의 연속적 메모리를 프로세스에 할당. 즉 프로세스 하나당 메모리 부분.

> 비연속 메모리 할당(페이징 & 세그멘테이션)은 프로세스를 여러블럭으로 나눠서 메모리의 다른 주소 공간에 배치
 

## 메모리 할당 방법
1. multiple partition allocation(다중 분할 방식)
  - 가장 간단한 방법이다.
  - memory를 똑같은 고정된 크기로 분할하는것 이다. 
  - 각 분할된 부분(partition)마다 한 process를 가진다. 
이 방식은 한 분할된 공간이 비게 되면 다른 프로세스가 입력 큐에서 선택되어 빈 공간에 들어오게 된다. 

2. fixed partition allocation(가변 분할 방식)
  - 메모리에서 어떤 부분이 사용되고 있고 어떤 부분이 사용되고 있지 않은지 파악하는 table이 있다. 
  - 처음에는 모든 메모리가 사용자 프로세스에서 사용이 가능하다.
  - 이 사용가능한 메모리들을 "Hole"이라고 부른다.
  - 프로세스가 메모리의 빈공간을 찾으면 우리는 프로세스를 담을 수 있는 Hole을 찾는다.
  - 공간이 있다면 메모리를 프로세스에게 할당해준다. 
  - 공간이 없다면 공간이 생길때 까지 대기하거나 작은 메모리를 요구하는 프로세스들이 있는지 보기 위해 input queue로 돌아간다. 
  - 하지만 이 방법을 사용하면 동적 메모리 할당 문제에 부딫히게 된다. 

> 동적 메모리 할당 문제  
- 프로세스들이 메모리를 할당받고 끝나면 되돌려주는 과정에서 빈공간이 여기 저기 생기게 된다. 이 빈공간들을 어떻게 다른 process에 할당해 줄지 정하는 알고리즘을 보자.

### 메모리 할당 알고리즘
1. First Fit(최초적합)  
이 방법은 첫번째 사용가능한 공간을 할당하는 방식이다. 
![images](/images/firstfit.png)
<br>
- 여기서 보면 노란색 공간은 사용중인 공간이라 사용할 수 없다. 프로세스 A는 25kb의 메모리 공간을 필요로 한다. 
- 그럼 우리는 사용가능한 공간중 25kb보다 큰 공간을 찾는다. 
- 여기서 보면 os 다음 20kb는 25kb보다 작으므로 사용할 수 없고 다음사용가능한 공간인 15kb도 사용 가능하지 않다. 
- 그러므로 다음 사용가능한 공간인 40kb공간을 할당하게 된다. 

2. Best Fit(최적 적합)  
사용가능한 공간중 가장 작은 것을 택해 할당하는 방식이다. 
![images](/images/bestfit.png)
<br>
- 프로세스A는 25이므로 사용가능한 공간중에(40kb, 60kb, 25kb)중에 가장 작은 것인 25kb공간을 사용할 수 있다.
- 여기서 20kb와 15kb공간은 25kb보다 작으므로 사용할 수 없는 공간이다. 

3. Worst Fit(최악 적합)  
사용가능한 공간중 가장 큰 공간을 택해 할당하는 방식이다. 

![images](/images/worstfit.png)
<br>
- 프로세스는 25kb인데 메모리에서 사용할 수 있는 가장 큰 공간인 60kb를 할당해준다. 
- 왜 이런 알고리즘이 나왔나 보면 프로세스를  할당해주고 남은 공간이 커야 또 다른 프로세스를 위해서 사용할 수 있다 라는 생각으로 만들어졌다. 

> 시뮬레이션에서 최초 적합과 최적 적합 모두 시간과 메모리 이용 효율 면에서 최악적합보다는 좋다고 증명 되었다. 이 후 first fit과 best fit을 비교해봤더니 메모리 효율은 둘이서 별 차이가 없었고 속도는 first fit 즉 최초 적합이 더 빠르다고 합니다. 그래서 상황에 따라 더 적합한것을 사용해야 한다.

## 단편화(fragmentation)  
위에서 봤던 할당방식을 찾는 이유가 바로 이 단편화 때문이다. 단편화는 메모리 공간중 일부가 사용할 수 없게 되는것을 말한다. 단편화는 외부단편화(external fragmentation)과 내부단편화(internal fragmentation)으로 나뉜다.

### 외부단편화(external fragmentation)   
위에서 봤던 메모리 할당 알고리즘들은 모두 외부단편화를 줄이기 위해 사용했던 것이다. 다시 설명하자면 외부 단편화는 메모리들이 프로세스에게 할당되고 돌아오는 일들이 반복되다 보면, 어떤 hole(사용가능한 메모리 공간)은 너무 작은 조각이 되어버린다. 메모리에 있는 모든 hole들을 합치면 사용할 수 있는 공간이지만 이렇게 여러곳에 분산되어서 사용할 수 없는 문제를 외부단편화라고 부른다.  
단편화를 줄이기 위해 사용했던 first fit 과 best fit알고리즘 둘다 결국엔 외부단편화 문제가 생긴다. 어느 공간에 넣든 결국에는 자투리 공간이 생기기 때문이다. fixed partition allocation(가변 분할 방식)에서 발생한다. 

> Compaction(압축)  
![images](/images/compaction.png)
그래서 옛날 사람들은 이 방법을 떠오렸다. 
사용할 수 있는 자투리 공간들은 한곳으로 모아서 사용하는것이다. 하지만 이방법은 프로세스들을 옮기기 위해 어떠한 공간이 필요하다. 예를 들면 사진에서 프로세스2,3,4들을 옮기기 위해 다른 공간에다 복사를 했다가 다시 이 메모리에 복사해와야한다. 그래서 secondary storage 하드디스크에다 임시로 복사해서 저장해야하는데 하드디스크는 엄청느려 결국엔 사용할 수 없는 방법이 되었다.

### 50%규칙  
예시로 보자, 최초 적합을 기준으로 N개의 블록이 할당되었을때 0.5N개의 블록이 단편화 때문에 손실될 수 있다. (총 1.5 중 0.5손실 ) 이 말은 즉, 메모리의 3분의 1이 쓸 수 없게 되었다는 뜻이다.   

> 하지만 메모리 엄청 비싼 자원이고 낭비는 허용할수 없다!! 그래서 나온것이 Paging과 segmentation이다.  

### 내부 단편화  
외부단편화와 반대로   
![images](/images/internalFragmentation.png)
할당된 메모리 공간이 프로세스의 크기보다 조금 더 커서 생성된 자투리 공간이 생기는 것을 내부단편화라고한다.   
내부 단편화는 이렇게 생긴 자투리 공간이 작아 다른 프로세스들도 사용하지 못하는것을 말한다. 또 multiple partition allocation(다중 분할 방식)에서 자주 발생한다.  


> 한마디로 정리하면 외부단편화는 메모리를 프로세스에 할당하고 반납하다보면 자투리 공간이 생기는데 그 공간들이 다 떨어져 있어서 사용하지 못하는것을 __외부단편화__ 라고하고 반대로 __내부단편화__ 는 프로세스보다 큰 메모리 공간을 할당했을때 생기는 자투리 공간이 생기는 것이다.


> 참고자료  
- https://www.geeksforgeeks.org/memory-management-in-operating-system/

- https://jhnyang.tistory.com/notice/31

- https://www.geeksforgeeks.org/difference-between-contiguous-and-noncontiguous-memory-allocation/#:~:text=1.,process%20or%20file%20needing%20it.&text=The%20main%20memory%20is%20a,other%20for%20the%20user%20program.

- http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791156006220#N
